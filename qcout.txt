            
            //cycle: starts from 1, chan = A,C,G,T, subimage is from [1,12]
            //"cycle chan subimage offsetx offsety rotation scalex scaley MR"
            {//write gridFitting.QC.txt
                FILE * file = fopen((crPath / "gridFitting.QC.txt").string().c_str(), "w");
                for (int cycle = 0; cycle < numCycles; cycle ++ )
                {
                    for (int chan = 0; chan < 4; chan ++ )
                    {
                        for (int i = 0; i < subImageSize; i++)
                        {
                            fprintf(file, "%d %c %d ", cycle+1, BASE[chan], i+1);
                            fprintf(file, "%lf ", gridInfos[cycle][chan][i].offsetX);
                            fprintf(file, "%lf ", gridInfos[cycle][chan][i].offsetY);
                            fprintf(file, "%lf ", gridInfos[cycle][chan][i].rotation);
                            fprintf(file, "%lf ", gridInfos[cycle][chan][i].scaleX);
                            fprintf(file, "%lf ", gridInfos[cycle][chan][i].scaleY);
                            fprintf(file, "%lf\n", gridInfos[cycle][chan][i].matchingRate);
                        }
                    }
                }
                fclose(file);
            }
            
            //"cycle chan offsetX, offsetY"
            {//write cropImage.QC.txt
                FILE * file = fopen((crPath / "cropImage.QC.txt").string().c_str(), "w");
                for (int cycle = 0; cycle < numCycles; cycle ++ )
                {
                    for (int chan = 0; chan < 4; chan ++ )
                    {
                        fprintf(file, "%d %c %f %f\n", cycle + 1, BASE[chan], offsetPoints[cycle][chan].x,offsetPoints[cycle][chan].y);
                    }
                }
                fclose(file);
            }

            //mt.makeTemplate(subPointSets, subGridInfos, templateMaps[i], countPoints[i]);
            //when cycle is 0, it means all cycle template
            //"cycle subimage pointsCount "
            {//write makeTemplate.QC.txt
                FILE * file = fopen((crPath / "makeTemplate.QC.txt").string().c_str(), "w");
                for (int sub = 0; sub < subImageSize; sub++)
                {
                    fprintf(file, "0 %d %d\n", sub + 1, cv::countNonZero(templateMaps[sub]));
                }

                for (int cycle = 0; cycle < int(countPoints[0].size()); cycle ++ )
                {
                    for (int i = 0; i < subImageSize; i++)
                    {
                        fprintf(file, "%d %d %d\n", cycle+1, i+1, countPoints[i][cycle]);
                    }
                }
                fclose(file);
            }
            
            // Crosstalk ct;
            // ct.getCrosstalk(subPointSets[cycle], mCross[i][cycle], subGridInfos[cycle]);
            //"cycle subimage AA AC AG AT CC CG CT GG GT TT" 
            {//write crosstalk.QC.txt
                FILE * file = fopen((crPath / "crosstalk.QC.txt").string().c_str(), "w");
                for (int cycle = 0; cycle < numCycles; cycle ++ )
                {
                    for (int i = 0; i < subImageSize; i++)
                    {
                        fprintf(file, "%d %d", cycle+1, i+1); 
                        for (int j = 0; j < int(mCross[i][cycle].size()); j++)
                        {
                            fprintf(file, " %d", mCross[i][cycle][j]); 
                        }
                        fprintf(file, "\n");
                    }
                }
                fclose(file);
            }